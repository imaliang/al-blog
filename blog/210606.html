<!DOCTYPE html><html lang="zh-CN"><head><link rel="preconnect" href="/assets" crossorigin=""><link rel="preconnect" href="https://cdn.staticfile.org" crossorigin=""><link rel="preconnect" href="https://cravatar.cn" crossorigin=""><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#313135" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#181c27" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon.ico"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"www.aliang.link","root":"/","images":"/assets/","scheme":"Gemini","darkmode":true,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"dimmer":false},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://cdn.staticfile.org/hexo-theme-next/8.17.1/config.min.js"></script><meta name="description" content="01. JAVA中的几种基本数据类型是什么，各自占用多少字节？ JAVA的八种基本数据类型  整型  byte 、 short 、 int 、 long   浮点型  float 、 double   字符型  char   布尔型  boolean"><meta property="og:type" content="article"><meta property="og:title" content="面试总结-基础篇"><meta property="og:url" content="https://www.aliang.link/blog/210606.html"><meta property="og:site_name" content="一页书"><meta property="og:description" content="01. JAVA中的几种基本数据类型是什么，各自占用多少字节？ JAVA的八种基本数据类型  整型  byte 、 short 、 int 、 long   浮点型  float 、 double   字符型  char   布尔型  boolean"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.aliang.link/assets/img/2021/01-05-1.jpg"><meta property="og:image" content="https://www.aliang.link/assets/img/2021/01-05-2.jpg"><meta property="og:image" content="https://www.aliang.link/assets/img/2021/01-30.png"><meta property="article:published_time" content="2021-06-06T07:45:30.000Z"><meta property="article:modified_time" content="2022-11-22T07:45:30.000Z"><meta property="article:author" content="aliang"><meta property="article:tag" content="Java"><meta property="article:tag" content="编程"><meta property="article:tag" content="面试问题"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.aliang.link/assets/img/2021/01-05-1.jpg"><link rel="canonical" href="https://www.aliang.link/blog/210606.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.aliang.link/blog/210606.html","path":"/blog/210606.html","title":"面试总结-基础篇"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>面试总结-基础篇 | 一页书</title><link rel="stylesheet" href="/assets/fonts/lxgw/lxgwwenkailite-regular.css"><link rel="stylesheet" type="text/css" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="一页书" type="application/atom+xml">
</head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">一页书</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">你永远不会过度准备</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="站内搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-java"><a href="/java/" rel="section"><i class="fas fa-coffee fa-fw"></i>Java</a></li><li class="menu-item menu-item-markdown"><a href="/md/" rel="section"><i class="fa fa-edit fa-fw"></i>Markdown</a></li><li class="menu-item menu-item-linux"><a href="https://linux.aliang.link/" rel="section" target="_blank"><i class="fas fa-brands fa-linux fa-fw"></i>Linux</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>博客分类</a></li><li class="menu-item menu-item-culture"><a href="/culture/" rel="section"><i class="fas fa-guitar fa-fw"></i>文艺清单</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fas fa-link fa-fw"></i>网站友链</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>站内搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">目 录</li><li class="sidebar-nav-overview">主页</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#01-JAVA%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%90%84%E8%87%AA%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="nav-text">01. JAVA中的几种基本数据类型是什么，各自占用多少字节？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-String%E7%B1%BB%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">02. String类能被继承吗，为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03-final%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-text">03. final的用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#04-String%EF%BC%8CStringbuffer%EF%BC%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">04. String，Stringbuffer，StringBuilder的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#05-ArrayList%E5%92%8CLinkedList%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">05. ArrayList和LinkedList有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#06-%E8%AE%B2%E8%AE%B2%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%8C%E6%AF%94%E5%A6%82%E7%88%B6%E7%B1%BB%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%AD%90%E7%B1%BB%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%BD%93new%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BB%96%E4%BB%AC%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E3%80%82"><span class="nav-text">06. 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#07-%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9BMap%E7%B1%BB%EF%BC%8C%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8CHashMap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8B%E4%BD%BF%E7%94%A8%E7%9A%84Map%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BB%96%E4%BB%AC%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%AF%94%E5%A6%82%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%EF%BC%8Chashcode%EF%BC%8C%E6%89%A9%E5%AE%B9%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%AE%B9%E9%87%8F%E7%AD%89%E3%80%82"><span class="nav-text">07. 用过哪些Map类，都有什么区别，HashMap是线程安全的吗，并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#08-JAVA8%E7%9A%84ConcurrentHashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E5%BC%83%E4%BA%86%E5%88%86%E6%AE%B5%E9%94%81%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%9D%A5%E8%AE%BE%E8%AE%A1%EF%BC%8C%E4%BD%A0%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E3%80%82"><span class="nav-text">08. JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#09-ConcurrentHashMap-JDK1-8-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8synchronized%E8%80%8C%E4%B8%8D%E6%98%AF%E5%A6%82ReentranLock%E8%BF%99%E6%A0%B7%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%9F"><span class="nav-text">09. ConcurrentHashMap(JDK1.8)为什么要使用synchronized而不是如ReentranLock这样的可重入锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E6%9C%89%E6%B2%A1%E6%9C%89%E6%9C%89%E9%A1%BA%E5%BA%8F%E7%9A%84Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%EF%BC%8C%E4%BB%96%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E7%9A%84%EF%BC%9F"><span class="nav-text">10. 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%A4%9A%E4%B8%AA%E7%B1%BB%E4%B9%88%EF%BC%8C%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B9%88%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B9%88%EF%BC%9F"><span class="nav-text">11. 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么，可以实现多个接口么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E7%BB%A7%E6%89%BF%E5%92%8C%E8%81%9A%E5%90%88%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="nav-text">12. 继承和聚合的区别在哪？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E4%BB%80%E4%B9%88%E6%98%AFIO%E6%A8%A1%E5%9E%8B%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E8%AE%B2%E8%AE%B2%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84nio-%EF%BC%8C%E4%BB%96%E5%92%8Cbio%EF%BC%8Caio%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E5%95%A5%EF%BC%8C%E8%B0%88%E8%B0%88reactor%E6%A8%A1%E5%9E%8B%E3%80%82"><span class="nav-text">13. 什么是IO模型？有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">14. 反射的原理，反射创建类实例的三种方式是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E5%8F%8D%E5%B0%84%E4%B8%AD%EF%BC%8CClass-forName%E5%92%8CClassLoader%E5%8C%BA%E5%88%AB-%E3%80%82"><span class="nav-text">15. 反射中，Class.forName和ClassLoader区别 。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E6%8F%8F%E8%BF%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%88%86%E5%88%AB%E8%AF%B4%E5%87%BA%E7%9B%B8%E5%BA%94%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">16. 描述动态代理的几种实现方式，分别说出相应的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">17. jdk动态代理与cglib动态代理的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E5%86%99%E5%87%BA%E4%B8%89%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">18. 写出三种单例模式的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E8%AF%B7%E7%BB%93%E5%90%88OO%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%EF%BC%8C%E8%B0%88%E8%B0%88%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6public%E3%80%81private%E3%80%81protected%E3%80%81default%E5%9C%A8%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82"><span class="nav-text">19. 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB"><span class="nav-text">20. 深拷贝和浅拷贝区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E5%A6%82%E4%BD%95%E5%9C%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E4%B8%BA%E5%AD%90%E7%B1%BB%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E7%9A%84hashcode%E5%92%8Cequals%E5%AE%9E%E7%8E%B0%EF%BC%9F%E8%BF%99%E4%B9%88%E5%81%9A%E6%9C%89%E4%BD%95%E4%BC%98%E5%8A%A3%EF%BC%9F"><span class="nav-text">21. 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9java-lang-Object%E5%AF%B9%E8%B1%A1%E4%B8%ADhashCode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">22. 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8F%AF%E8%83%BD2%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84hashcode%EF%BC%9F"><span class="nav-text">23. 有没有可能2个不相等的对象有相同的hashcode？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-%E8%BF%99%E6%A0%B7%E7%9A%84a-hashcode-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%8C%E4%B8%8Ea-equals-b-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%E3%80%82"><span class="nav-text">24. 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%82"><span class="nav-text">25. 数组和链表数据结构描述，各自的时间复杂度。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-error%E5%92%8Cexception%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8CCheckedException%EF%BC%8CRuntimeException%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-text">26. error和exception的区别，CheckedException，RuntimeException的区别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-%E5%B8%B8%E8%A7%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8-RuntimeException"><span class="nav-text">27. 常见运行时异常 (RuntimeException)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E5%B8%B8%E8%A7%81%E9%9D%9E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8-CheckedException"><span class="nav-text">28. 常见非运行时异常 (CheckedException)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF-Error"><span class="nav-text">29. 常见错误 (Error)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAjava-lang-String%E7%B1%BB%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">30. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="nav-text">31. 什么是向下转型和向上转型?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E5%9C%A8jdk1-5%E4%B8%AD%EF%BC%8C%E5%BC%95%E5%85%A5%E4%BA%86%E6%B3%9B%E5%9E%8B%EF%BC%8C%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AD%98%E5%9C%A8%E6%98%AF%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E3%80%82"><span class="nav-text">32. 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-Java%E4%B8%AD%E7%9A%84HashSet%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E3%80%82"><span class="nav-text">33. Java中的HashSet内部是如何工作的。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BC%9A%E9%81%87%E5%88%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-text">34. 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-HTTP-GET%E5%92%8C-HTTP-POST-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">35. HTTP GET和 HTTP POST 的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">36. java8的新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%B4%E8%B0%A2"><span class="nav-text">致谢</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="aliang" src="/assets/head.webp"><p class="site-author-name" itemprop="name">aliang</p><div class="site-description" itemprop="description">JAVA/游戏/电影</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">归档</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://aliang.link/" title="主页 → https:&#x2F;&#x2F;aliang.link" rel="noopener me" target="_blank"><i class="fas fa-desktop fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://tool.aliang.link/" title="导航 → https:&#x2F;&#x2F;tool.aliang.link" rel="noopener me" target="_blank"><i class="fas fa-globe fa-fw"></i></a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fas fa-rss fa-fw"></i></a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.aliang.link/blog/210606.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/head.webp"><meta itemprop="name" content="aliang"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一页书"><meta itemprop="description" content="JAVA/游戏/电影"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="面试总结-基础篇 | 一页书"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">面试总结-基础篇</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-06-06 15:45:30" itemprop="dateCreated datePublished" datetime="2021-06-06T15:45:30+08:00">2021-06-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-22 15:45:30" itemprop="dateModified" datetime="2022-11-22T15:45:30+08:00">2022-11-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">面试总结</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="01-JAVA中的几种基本数据类型是什么，各自占用多少字节？">01. JAVA中的几种基本数据类型是什么，各自占用多少字节？</h2><p><strong>JAVA的八种基本数据类型</strong></p><ul><li>整型<ul><li>byte 、 short 、 int 、 long</li></ul></li><li>浮点型<ul><li>float 、 double</li></ul></li><li>字符型<ul><li>char</li></ul></li><li>布尔型<ul><li>boolean</li></ul></li></ul><span id="more"></span><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">占用字节</th><th style="text-align:center">默认值</th><th style="text-align:center">封装类</th></tr></thead><tbody><tr><td style="text-align:center"><strong>byte(字节型)</strong></td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center"><strong>Byte</strong></td></tr><tr><td style="text-align:center"><strong>short(短整形)</strong></td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center"><strong>Short</strong></td></tr><tr><td style="text-align:center"><strong>int(整形)</strong></td><td style="text-align:center">4</td><td style="text-align:center">0</td><td style="text-align:center"><strong>Integer</strong></td></tr><tr><td style="text-align:center"><strong>long(长整形)</strong></td><td style="text-align:center">8</td><td style="text-align:center">0.0l</td><td style="text-align:center"><strong>Long</strong></td></tr><tr><td style="text-align:center"><strong>float(浮点型)</strong></td><td style="text-align:center">4</td><td style="text-align:center">0.0f</td><td style="text-align:center"><strong>Float</strong></td></tr><tr><td style="text-align:center"><strong>double(双精度浮点型)</strong></td><td style="text-align:center">8</td><td style="text-align:center">0</td><td style="text-align:center"><strong>Double</strong></td></tr><tr><td style="text-align:center"><strong>char(字符型)</strong></td><td style="text-align:center">2</td><td style="text-align:center">\u0000(空格)</td><td style="text-align:center"><strong>Character</strong></td></tr><tr><td style="text-align:center"><strong>boolean(布尔型)</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>Boolean</strong></td></tr></tbody></table><!-- more --><div class="note primary"><h4 id="注：">注：</h4><p>boolean在java规范里并没有规定大小；<br>网上说的大小有很多，比如1个bit（1/8个字节）、1个字节、4个字节；<br>我更倾向于4个字节，因为boolean类型会被编译为int类型，等于是说JVM里占用字节和int完全一样，int是4个字节，所以boolean也是4字节</p></div><h2 id="02-String类能被继承吗，为什么？">02. String类能被继承吗，为什么？</h2><p><strong>不能</strong> 因为String被关键字final修饰。</p><h2 id="03-final的用途">03. final的用途</h2><p>final是一种修饰符，是一种规定，可以用于修饰类、成员方法和成员变量</p><ul><li>final所修饰的类：不能被继承，不能有子类</li><li>final所修饰的方法：不能被重写</li><li>final所修饰的变量：是不可以修改的，是常量</li></ul><h2 id="04-String，Stringbuffer，StringBuilder的区别？">04. String，Stringbuffer，StringBuilder的区别？</h2><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center"><div style="width:80px">值是否可变</div></th><th style="text-align:center"><div style="width:70px">线程安全</div></th><th style="text-align:center"><div style="width:80px">常用</div></th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center"><strong>String</strong></td><td style="text-align:center">不可变</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left">String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</td></tr><tr><td style="text-align:center"><strong>StringBuffer</strong></td><td style="text-align:center">可变</td><td style="text-align:center">线程安全</td><td style="text-align:center">多线程操作字符串</td><td style="text-align:left">StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td></tr><tr><td style="text-align:center"><strong>StringBuilder</strong></td><td style="text-align:center">可变</td><td style="text-align:center">线程不安全</td><td style="text-align:center">单线程操作字符串</td><td style="text-align:left">可变类，速度更快</td></tr></tbody></table><blockquote><p>对于字符串拼接，我们实际使用中不用过于纠结是使用String还是StringBuffer与StringBuilder；现代JDK中编译时就会进行优化会将字符串拼接（+号拼接）优化为StringBuffer，甚至如&quot;a&quot;+“b&quot;这样的凭借会直接编译优化为&quot;ab”；因此还是优先考虑代码的可读性和美观，但是通过for循环拼接字符串时请使用StringBuffer或StringBuilder。</p></blockquote><h2 id="05-ArrayList和LinkedList有什么区别？">05. ArrayList和LinkedList有什么区别？</h2><div class="note success"><ul><li>ArrayList 查询快</li><li>LinkedList 增删快</li><li>因为ArrayList底层是一个数组，所以查询快；LinkedList底层是一个链表，所以增删快。</li></ul></div><p><img data-src="/assets/img/2021/01-05-1.jpg" alt="ArrayList与LinkedList" title="ArrayList与LinkedList"></p><p>如图所示，假设有一int类型类型的数组，每个int对象都有内存大小，占用4个字节。如果我们要查找第3个对象,可以通过(3-1)*4=8，故9到12字节就是我们要找的对象。是不是很快呢？而链表却不能做到这样的效率。如上图，我们要找到A3，必须先找到A2，要想找到A2，又必须先找到A1；这样的查找效率会大大降低。</p><p><img data-src="/assets/img/2021/01-05-2.jpg" alt="ArrayList与LinkedList插入图解" title="ArrayList与LinkedList插入图解"></p><p>如上图所示，数组的插入也相当的浪费效率；如果要在数组内的某一个位置进行插入，需要先将插入位置的前面复制一份，然后在新的数组后面添加新的元素，最后将旧的数组后半部分添加的新的数组后面；而在链表中插入就变得相当简单了，比如我要在A1和A2中插入A10,只需定位到A1的指针和A2的数据即可,将A1的指针指向A10的值,将A10的指针指向A2的值，A10就插入进了链表。</p><h2 id="06-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。">06. 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。</h2><div class="note success"><h4 id="类的实例化顺序：">类的实例化顺序：</h4><ol><li><strong>先静态</strong>： 先静态，后非静态</li><li><strong>先父后子</strong>： 先父类同级，后子类同级</li><li><strong>优先级： 字段 &gt; 带参构造函数 &gt; 无参构造函数 &gt; 普通函数</strong></li><li>同级： 从上到下依次执行</li></ol></div><h2 id="07-用过哪些Map类，都有什么区别，HashMap是线程安全的吗，并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。">07. 用过哪些Map类，都有什么区别，HashMap是线程安全的吗，并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。</h2><p>常见的Map类有 <strong>HashMap</strong> 、 <strong>ConcurrentHashMap</strong> 、 <strong>HashTable</strong> 、 <strong>LinkedHashMap</strong> 和 <strong>TreeMap</strong> 。</p><p>并发下常使用 <strong>ConcurrentHashMap</strong></p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center"><div style="width:80px">存储方式</div></th><th style="text-align:center">是否允许空值</th></tr></thead><tbody><tr><td style="text-align:center"><strong>HashMap</strong></td><td style="text-align:center">根据键的HashCode值存储数据</td><td style="text-align:center">最多只允许一条记录的键为 Null；允许多条记录的值为 Null</td></tr><tr><td style="text-align:center"><strong>HashTable</strong></td><td style="text-align:center">同上</td><td style="text-align:center">键或值都不允许为 Null</td></tr><tr><td style="text-align:center"><strong>LinkedHashMap</strong></td><td style="text-align:center">同上</td><td style="text-align:center">同 HashMap</td></tr><tr><td style="text-align:center"><strong>TreeMap</strong></td><td style="text-align:center">同上</td><td style="text-align:center">不允许键为Null；允许多条记录的值为 Null</td></tr></tbody></table><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">默认容量</th><th style="text-align:center">扩容机制</th><th style="text-align:center">是否有序</th></tr></thead><tbody><tr><td style="text-align:center"><strong>HashMap</strong></td><td style="text-align:center">16（必须为2的整数次幂）</td><td style="text-align:center">容量变为原来的2倍</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center"><strong>HashTable</strong></td><td style="text-align:center">11（不要求底层数组的容量一定要为2的整数次幂）</td><td style="text-align:center">容量变为原来的2倍加1</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center"><strong>LinkedHashMap</strong></td><td style="text-align:center">容量没有限制</td><td style="text-align:center">-</td><td style="text-align:center">默认是数据插入顺序</td></tr><tr><td style="text-align:center"><strong>TreeMap</strong></td><td style="text-align:center">容量没有限制</td><td style="text-align:center">-</td><td style="text-align:center">默认是key升序</td></tr></tbody></table><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center"><div style="width:80px">线程安全</div></th><th style="text-align:center">优缺点</th></tr></thead><tbody><tr><td style="text-align:center"><strong>HashMap</strong></td><td style="text-align:center">否</td><td style="text-align:center">很快的访问速度，而且在Map中插入、删除和定位元素，HashMap 是最好的选择。</td></tr><tr><td style="text-align:center"><strong>HashTable</strong></td><td style="text-align:center">是</td><td style="text-align:center">它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了 Hashtable在写入时会比较慢</td></tr><tr><td style="text-align:center"><strong>LinkedHashMap</strong></td><td style="text-align:center">否</td><td style="text-align:center">LinkedHashMap是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。</td></tr><tr><td style="text-align:center"><strong>TreeMap</strong></td><td style="text-align:center">否</td><td style="text-align:center">TreeMap取出来的是排序后的键值对。但如果要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。</td></tr></tbody></table><h2 id="08-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。">08. JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。</h2><p>弃用原因：</p><ul><li>加入多个分段锁浪费内存空间。</li><li>生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。</li><li>为了提高 GC（垃圾回收） 的效率。</li><li>为了降低锁的粒度，提高性能。</li></ul><blockquote><p>JDK8 放弃了分段锁而是用了 <mark>Node数组+链表+红黑树</mark> 的数据结构来实现，并发控制使用 <strong>Synchronized</strong> 和 <strong>CAS</strong> 来操作，在没有hash冲突的情况下直接使用cas来操作，没有锁的性能开销，当hash冲突时，则直接用链表第一个object加锁，这里加的锁是synchronized，虽然效率不如 ReentrantLock， 但节约了空间，整个看起来就像是优化过且线程安全的HashMap。</p></blockquote><h2 id="09-ConcurrentHashMap-JDK1-8-为什么要使用synchronized而不是如ReentranLock这样的可重入锁？">09. ConcurrentHashMap(JDK1.8)为什么要使用synchronized而不是如ReentranLock这样的可重入锁？</h2><ul><li>减少内存开销<br>假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</li><li>获得JVM的支持<br>可重入锁毕竟是API这个级别的，后续的性能优化空间很小。<br>synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。</li></ul><h2 id="10-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的？">10. 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的？</h2><p>TreeMap和LinkedHashmap都是有序的</p><p>TreeMap默认是 <strong>key升序</strong> ，也可以自定义排序规则：要实现Comparator接口</p><p>LinkedHashmap默认是数据 <strong>插入顺序</strong></p><p><strong>TreeMap 底层存储结构是二叉树，二叉树的中序遍历保证了数据的有序性</strong></p><p><strong>LinkedHashMap 底层存储结构是哈希表+链表，链表记录了添加数据的顺序</strong></p><h2 id="11-抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么，可以实现多个接口么？">11. 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么，可以实现多个接口么？</h2><ul><li><p>不同点：</p><ul><li>抽象类要被子类继承，接口要被类实现。</li><li>接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现</li><li>接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。</li></ul></li><li><p>共同点：</p><ul><li>抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。</li><li>抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。</li><li>抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。</li></ul></li><li><p>其它：</p><ul><li>抽象类里可以没有抽象方法</li><li>如果一个类里有抽象方法，那么这个类只能是抽象类</li><li>抽象方法要被实现，所以不能是静态的，也不能是私有的。</li></ul></li></ul><div class="note warning"><h4 id="注意">注意</h4><ul><li>类只能继承一个类，但是可以实现多个接口。</li><li><strong>接口</strong>只能继承接口，但是<strong>可多继承接口</strong>。</li></ul></div><h2 id="12-继承和聚合的区别在哪？">12. 继承和聚合的区别在哪？</h2><ul><li><p>继承指的是一个类继承另外的一个类的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识。</p></li><li><p>聚合体现的是整体与部分、拥有的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期；比如计算机与CPU、公司与员工的关系等；在java中表现在代码层面，只能从语义级别来区分。</p></li></ul><p>扩展：</p><ul><li>实现：指的是一个class类实现interface接口（可以是多个）的功能；实现是类与接口之间最常见的关系；在Java中此类关系通过关键字implements明确标识</li><li>依赖：可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖；表现在代码层面，为类B作为参数被类A在某个method方法中使用。</li><li>关联：体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。</li><li>组合：组合也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑；表现在代码层面，和关联关系是一致的，只能从语义级别来区分。</li></ul><h2 id="13-什么是IO模型？有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型。">13. 什么是IO模型？有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。</h2><ul><li>什么是IO模型？<ul><li>IO模型就是说用什么样的通道进行数据的发送和接收，Java共支持3种网络编程IO模式：NIO、BIO、AIO</li></ul></li><li>介绍：<ul><li><mark>NIO</mark>：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理</li><li><mark>BIO</mark>：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程并处理，如果这个连接不做任何事情会造成不必要的开销，当然可以通过线程池机制改善</li><li><mark>AIO(NIO2)</mark>：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理</li></ul></li><li>使用场景：<ul><li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li><li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li><li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li></ul></li></ul><h2 id="14-反射的原理，反射创建类实例的三种方式是什么？">14. 反射的原理，反射创建类实例的三种方式是什么？</h2><ul><li>反射的原理：<ul><li>我们都知道java类的执行需要编译、加载、连接、初始化四步。反射的原理就是加载时，jvm通过字节码class文件，生成相应的对象。</li></ul></li><li>反射创建类实例的三种方式：<ul><li><strong>对象.getClass()</strong></li><li><strong>类.class</strong></li><li><strong>Class.forName(“全路径名称”)</strong></li></ul></li><li>详细介绍请移步：<a href="/pages/92ad8f/" title="点我查看">什么是反射</a></li></ul><h2 id="15-反射中，Class-forName和ClassLoader区别-。">15. 反射中，Class.forName和ClassLoader区别 。</h2><ul><li>Java中Class.forName和classloader都可以用来对类进行加载。</li><li>Class.forName除了将类的 .class文件 加载到jvm中之外，还会对类进行解释，执行类中的static块。</li><li>而classloader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。</li><li>Class.forName(name,initialize,loader)带参数也可控制是否加载static块。</li></ul><h2 id="16-描述动态代理的几种实现方式，分别说出相应的优缺点">16. 描述动态代理的几种实现方式，分别说出相应的优缺点</h2><p>常见的动态代理有 <strong>jdk动态代理</strong> 、 <strong>cglib动态代理</strong></p><ul><li><p>jdk动态代理是由java内部的反射机制来实现的，它是jdk原生就支持的一种代理方式，它的实现原理，就是通过让target类和代理类实现同一接口，代理类持有target对象，来达到方法拦截的作用，这样通过接口的方式有两个弊端，一个是必须保证target类有接口，第二个是如果想要对target类的方法进行代理拦截，那么就要保证这些方法都要在接口中声明，实现上略微有点限制。</p></li><li><p>cglib动态代理是通过继承来实现的，底层则是借助asm(Java 字节码操控框架)来实现的（采用字节码的方式，给A类创建一个子类B，子类B使用方法拦截的技术拦截所有父类的方法调用）。</p></li><li><p>优缺点：</p><ul><li><strong>jdk动态代理有一定的局限性，只能基于接口。</strong></li><li><strong>cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。但无法处理final的情况，通过继承。</strong></li></ul></li></ul><h2 id="17-jdk动态代理与cglib动态代理的区别">17. jdk动态代理与cglib动态代理的区别</h2><ul><li>jdk动态代理只能对实现了接口的类生成代理，而不能针对类 ;</li><li>cglib是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 ; 因为是继承，所以该类或方法最好不要声明成final ，final可以阻止继承和多态。</li></ul><p>详情：<a href="/pages/3830a5/#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9%E3%80%81%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB">实现原理、优缺点、两者区别</a></p><h2 id="18-写出三种单例模式的实现">18. 写出三种单例模式的实现</h2><h4 id="18-1-单例模式之饿汉式">18.1 单例模式之饿汉式</h4><p>在类加载时就初始化一个类对象，使用静态加载，但是在类加载时就实例化对象，单例对象较大的时候会影响系统加载速度</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"This is constructor."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> getInstance <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre><h4 id="18-2-延迟加载的singleton">18.2 延迟加载的singleton</h4><p>只有在访问到单例对象的时候才去检查和实例化单例对象，满足延迟加载，但多线程访问时需要加线程同步，影响访问效率</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazySingleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">LazySingleton</span> instance <span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token class-name">LazySingleton</span> getInstance <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//对于多线程访问的需加synchronized</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span></code></pre><h4 id="18-3-使用静态内部类来作为singleton的容器">18.3 使用静态内部类来作为singleton的容器</h4><p>既能延迟加载，又能保证线程安全</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticSingleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token class-name">StaticSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">&#123;</span> <span class="token comment">//私有内部类在StaticSingleton 加载时，不初始化</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">StaticSingleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StaticSingleton</span> getInstance <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre><h2 id="19-请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。">19. 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。</h2><ul><li>OO 即 Object Oriented 面向对象的设计模式。</li><li>public：Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。</li><li>private：Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。</li><li>protected：介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。</li><li>default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。</li><li>作用域基本如下，越往下越小。<table><thead><tr><th style="text-align:center">作用域</th><th style="text-align:center">当前类</th><th style="text-align:center">同一package</th><th style="text-align:center">子孙类</th><th style="text-align:center">其它package</th></tr></thead><tbody><tr><td style="text-align:center"><strong>public</strong></td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center"><strong>protected</strong></td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center"><strong>default</strong></td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center"><strong>private</strong></td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table></li></ul><h2 id="20-深拷贝和浅拷贝区别">20. 深拷贝和浅拷贝区别</h2><p><strong><code>浅拷贝</code></strong> 基本类型拷贝值，引用类型只拷贝引用地址。</p><p><strong><code>深拷贝</code></strong> 引用类型也是拷贝他的值，重新生成的对像，clone出来对象与原对象互不影响。</p><h2 id="21-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣？">21. 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣？</h2><p>父类中重写hashcode和equals即可</p><p>优点：子类中我们不用再写。</p><p>缺点：有时候父类中equals和hashcode方法不满足我们的需求，需要重写。</p><h2 id="22-说一说你对java-lang-Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法？">22. 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法？</h2><ul><li>hashCode与equals方法都是Java Object对象中的方法，也就是说Java的一切对象都提供这两个方法。</li><li>当集合要添加新的元素时，首先会调用这个元素的hashCode方法，定位到它的物理位置；<br>如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；<br>如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。<br>所以这里存在一个冲突解决的问题，这个时候就需要重写。</li></ul><h2 id="23-有没有可能2个不相等的对象有相同的hashcode？">23. 有没有可能2个不相等的对象有相同的hashcode？</h2><ul><li>hashCode是所有java对象的固有方法；</li><li>如果不重载的话，返回的实际上是 <strong>该对象在jvm堆上的内存地址</strong> ，而不同对象的内存地址肯定不同，所以这个hashCode也就肯定不同了。</li><li>如果重载了的话，由于采用的算法的问题，有可能导致两个不同对象的hashCode相同。</li></ul><h2 id="24-这样的a-hashcode-有什么用，与a-equals-b-有什么关系。">24. 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。</h2><ul><li>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。</li><li>equals() 主要是用于比对两者的对象是否相同，相对于hashCode()是比较简单的。</li><li>两者主要在数据的存储方面有联系；</li><li>equals()的时间复杂度为O(n)，而hashCode()判断是否有相同元素的代价，只是一次哈希计算，时间复杂度为O(1)，这极大地提高了数据的存储性能。</li><li>当hashcode有冲突时，容器就能判断：这个新加入的元素已经存在，需要另作处理：覆盖掉原来的元素（key）或舍弃。</li><li>此时就需要再进行一个equals()的比对，只有当equals()也返回true的时候，才会认为元素重复，舍弃存储</li></ul><h2 id="25-数组和链表数据结构描述，各自的时间复杂度。">25. 数组和链表数据结构描述，各自的时间复杂度。</h2><h4 id="25-1-各自的特点">25.1 各自的特点</h4><ul><li><p>两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用</p></li><li><p>数组：<br>数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素（插入时），在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。</p></li><li><p>链表：<br>链表恰好相反，链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。</p></li></ul><h4 id="25-2-数组和链表的区别">25.2 数组和链表的区别</h4><ol><li>从逻辑结构角度来看：<ul><li>数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费。</li><li>链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项）</li></ul></li><li>数组元素在栈区，链表元素在堆区；</li><li>从内存存储角度来看：<ul><li>(静态)数组从栈中分配空间, 对于程序员方便快速,但自由度小。</li><li>链表从堆中分配空间, 自由度大但申请管理比较麻烦。</li><li>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；</li><li>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</li></ul></li></ol><h2 id="26-error和exception的区别，CheckedException，RuntimeException的区别。">26. error和exception的区别，CheckedException，RuntimeException的区别。</h2><ul><li><p>首先Exception和Error都是继承于Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p></li><li><p>Exception 是程序正常运行过程中可以预料到的意外情况，并且应该被开发者捕获，进行相应的处理。</p></li><li><p>Error是java程序运行中不可预料的异常情况（正常情况下不大可能出现的情况），这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。【表示由JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误 ，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。 Error类体系描述了Java运行系统中的内部错误以及资源耗尽的情形。应用程序不应该抛出这种类型的对象(一般是由虚拟机抛出)。假如出现这种错误，除了尽力使程序安全退出外，在其他方面是无能为力的。】</p></li><li><p>其中的Exception又分为检查性异常（checked）和非检查性异常（unchecked）（也叫RuntimeException）。</p></li><li><p>两个根本的区别在于：</p><ul><li>检查性异常 必须在编写代码时，使用try catch捕获（比如：IOException异常）。</li><li>非检查性异常 在代码编写使，可以忽略捕获操作（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的，具体根据需要来判断是否需要捕获，并不会在编译器强制要求。</li></ul></li></ul><h2 id="27-常见运行时异常-RuntimeException">27. 常见运行时异常 (RuntimeException)</h2><ul><li>NullPointerException (空指针异常)</li><li>IllegalArgumentException (传递非法参数异常)</li><li>ClassCastException (类转换异常)</li><li>IndexOutOfBoundsException (下标越界异常)</li><li>ArrayIndexOutOfBoundsException (数组越界异常)</li><li>ArrayStoreException (数据存储异常，操作数组时类型不一致)</li><li>NumberFormatException (数字格式异常)</li><li>BufferOverflowException (缓冲区溢出异常)</li><li>AruthmeticException (算术异常)</li></ul><h2 id="28-常见非运行时异常-CheckedException">28. 常见非运行时异常 (CheckedException)</h2><ul><li>IOException (IO 操作异常)</li><li>ClassNotFoundException (找不到指定 class 的异常)</li><li>FileNotFoundException (文件不存在异常)</li><li>SQLException (SQL语句异常）</li><li>InterruptedException (中断异常-调用线程睡眠时候)</li></ul><h2 id="29-常见错误-Error">29. 常见错误 (Error)</h2><ul><li>OutOfMemoryError (内存溢出错误)</li><li>NoClassDefFoundError (找不到 class 定义错误)</li><li>StackOverflowError (深递归导致栈被耗尽而抛出的错误)</li></ul><h2 id="30-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么？">30. 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么？</h2><p><strong>不能</strong></p><p><img data-src="/assets/img/2021/01-30.png" alt="JVM的四种类加载器" title="JVM的四种类加载器"></p><p>Java使用的是 <strong>双亲委托机制</strong> ：如果一个类加载器收到了类加载的请求，它首先不会自己尝试去加载这个类，而是把这个请求委派给父类加载器（BootStrap），每一个层次的类加载器都是加此，因此所有的加载请求最终到达顶层的启动类加载器，只有当父类加载器反馈自己无法完成加载请求时（指它的搜索范围没有找到所需的类），子类加载器才会尝试自己去加载。</p><p>因此，当你创建一个java.lang.String类时，启动类加载器首先加载的是java.lang.String本类，<br>加载你自己的java.lang.String类时，就会由虚拟机抛出的 <strong>java.lang.SecurityException:Prohibited package name:java.lang</strong> 异常。</p><h2 id="31-什么是向下转型和向上转型">31. 什么是向下转型和向上转型?</h2><ul><li>面向对象的转型只会发生在具有继承关系的父子类中（接口也是继承的一种）</li><li>向上转型：其核心目的在于参数的统一上，根本不需要强制类型转换。<br>向下转型：是为了操作子类定义的特殊功能，需要强制类型转换，可是现在存在的问题是：向下转型其实是一种非常不安全的操作，因为为编译的时候，程序不会报错，而在运行的时候会报错。</li></ul><h2 id="32-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题。">32. 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。</h2><ul><li><p><strong>泛型是用来解决向下转型时所带来的安全隐患（ClassCastException）</strong></p></li><li><p>泛型的核心意义在于：类在进行定义的时候可以使用一个标记，此标记就表示类中属性或者方法以及参数的类型，标记在使用的时候，才会去动态的设置类型。</p></li></ul><h2 id="33-Java中的HashSet内部是如何工作的。">33. Java中的HashSet内部是如何工作的。</h2><ul><li>HashSet 的内部采用 HashMap来实现。</li><li>由于 Map 需要 key 和 value，所以HashSet中所有 key 的都有一个默认 value。</li><li>类似于 HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。</li><li>HashSet 把存储的值作为 key。</li></ul><h2 id="34-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决？">34. 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决？</h2><ul><li>序列化：把对象转换为字节序列的过程称为对象的序列化。</li><li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化。</li><li>为什么序列化：序列化是为了将一个对象的状态（各个属性值）保存起来，然后在适当的时候再获得。</li><li>怎么序列化：实现Serializable接口即可</li><li>反序列化会遇到什么问题：随着版本的迭代，可能出现不认识旧数据的bug</li><li>解决办法：实现 Serializable 接口的时候，一定要给这个 <strong>serialVersionUID</strong> 赋值，赋值为 <strong>1L</strong> 即可。</li></ul><h2 id="35-HTTP-GET和-HTTP-POST-的区别是什么？">35. HTTP GET和 HTTP POST 的区别是什么？</h2><ol><li>GET参数通过URL传递，POST放在Request body中。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li></ol><blockquote><p><strong>但是GET和POST本质上都是TCP链接，并无差别。只是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</strong></p></blockquote><h2 id="36-java8的新特性">36. java8的新特性</h2><ul><li>Lambda表达式和函数式接口</li><li>接口的默认方法和静态方法</li><li>方法引用</li><li>重复注解</li><li>更好的类型推断</li><li>Stream流</li></ul><p>详解：<a href="https://www.aliang.link/pages/cc01c3/" title="点我查看">JAVA8 新特性</a></p><h2 id="致谢">致谢</h2><ol><li><a target="_blank" rel="noopener" href="https://github.com/0voice/interview_internal_reference" title="点我查看原文">interview_internal_reference</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/kevin_darkelf/article/details/11371353" title="点我查看原文">继承、实现、依赖、关联、聚合、组合的联系与区别</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42656794/article/details/90700595" title="点我查看原文">IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/riemann_/article/details/86849078" title="点我查看原文">描述Java动态代理的几种实现方式，分别说出相应的优缺点。</a></li><li><a target="_blank" rel="noopener" href="https://www.csdn.net/tags/MtTacgwsNzE5MjEtYmxvZwO0O0OO0O0O.html" title="点我查看原文">动态代理的几种实现方式</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/gsw204/article/details/52452873" title="点我查看原文">Java单例模式的三种实现方式</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/riemann_/article/details/87217229" title="点我查看原文">Java深入理解深拷贝和浅拷贝区别</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/riemann_/article/details/87564524" title="点我查看原文">数组和链表数据结构描述，各自的时间复杂度</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/riemann_/article/details/87522352" title="点我查看原文">Java异常error和exception的区别，CheckedException，RuntimeException的区别。</a></li><li><a target="_blank" rel="noopener" href="http://www.hellojava.com/a/90595.html" title="点我查看原文">Java中Error和Exception的异同以及运行时异常（Runtime exception)与检查型异常（checked exception）的区别</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/idea360/p/12377464.html" title="点我查看原文">JVM类加载器是否可以加载自定义的String</a></li><li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1280aa1ca58a" title="点我查看原文">JAVA基础面试试题及答案（阿里面试题-JAVA基础篇）</a></li></ol></div><footer class="post-footer"><div class="license"><div class="license-title">面试总结-基础篇</div><div class="license-link"><a href="https://www.aliang.link/blog/210606.html">https://www.aliang.link/blog/210606.html</a></div><div class="license-meta"><div class="license-meta-item"><div class="license-meta-title">本文作者</div><div class="license-meta-text">aliang</div></div><div class="license-meta-item"><div class="license-meta-title">发布于</div><div class="license-meta-text">2021-06-06</div></div><div class="license-meta-item"><div class="license-meta-title">更新于</div><div class="license-meta-text">2022-11-22</div></div><div class="license-meta-item"><div class="license-meta-title">许可协议</div><div class="license-meta-text">转载请注明出处</div></div></div><div class="license-statement">如需转载或引用本文，无需授权，注明出处即可，但不得用于商业用途！</div></div><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 编程</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" rel="tag"><i class="fa fa-tag"></i> 面试问题</a></div><div class="post-nav"><div class="post-nav-item"><a href="/blog/210607.html" rel="prev" title="面试总结-Redis篇"><i class="fa fa-chevron-left"></i> 面试总结-Redis篇</a></div><div class="post-nav-item"><a href="/blog/210523.html" rel="next" title="Redis 常见问题">Redis 常见问题 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments"><div id="twikoo-comments"></div></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fas fa-cog fa-spin"></i> </span><span class="author" itemprop="copyrightHolder">aliang</span></div><div class="footer-menu"><a href="/tags/">文章标签</a> · <a href="/policy/">网站政策</a> · <a href="/about/">站点简介</a></div><div id="footer-bdages"><a class="footer-badge" target="_blank" href="https://hexo.io/" style="margin-inline:3px" data-title="博客框架为Hexo v6.3.0" title="博客框架为Hexo_v6.3.0"><img src="/assets/badge/Frame-Hexo.svg" data-src="/img/badge/Frame-Hexo.svg" alt="" data-loaded="true"></a><a class="footer-badge" target="_blank" href="https://github.com/next-theme/hexo-theme-next/" style="margin-inline:3px" data-title="主题版本NexT.Gemini_v8.18.2" title="主题版本NexT.Gemini_v8.18.2"><img src="/assets/badge/Theme.NexT.Gemini.svg" data-src="/img/badge/Theme-Butterfly.svg" alt="" data-loaded="true"></a><a class="footer-badge" target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index" style="margin-inline:3px" data-title="本站已在京进行备案" title="本站已在京进行备案"><img src="/assets/badge/京ICP备2021015997号.svg" data-src="/img/badge/湘ICP备-2022004213号.svg" alt="" data-loaded="true"></a><a class="footer-badge" target="_blank" href="https://url.cn/m8IhMhnN" style="margin-inline:3px" data-title="本站项目部署于腾讯云服务，点我查看最新活动！" title="本站项目部署于腾讯云服务，点我查看最新活动！"><img src="/assets/badge/Cloud.Tencent.svg" data-src="/img/badge/Cloud.Tencent.svg" alt="" data-loaded="true"></a><a class="footer-badge" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" style="margin-inline:3px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="/assets/badge/Copyright-BY-NC-SA-4.0.svg" data-src="/img/badge/Copyright-BY-NC-SA 4.0 BY-NC-SA 4.0.svg" alt="" data-loaded="true"></a></div><div id="player"></div><script type="text/javascript" src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js"></script><script type="text/javascript" src="/assets/music/music.js"></script></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.staticfile.org/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="https://cdn.staticfile.org/jquery/3.7.0/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdn.staticfile.org/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdn.staticfile.org/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="https://cdn.staticfile.org/hexo-theme-next/8.17.1/comments.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-next/8.17.1/utils.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-next/8.17.1/next-boot.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-next/8.17.1/pjax.min.js"></script><script src="https://cdn.staticfile.org/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="https://cdn.staticfile.org/hexo-theme-next/8.17.1/third-party/search/local-search.min.js"></script><script src="https://cdn.staticfile.org/hexo-theme-next/8.17.1/third-party/fancybox.min.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdn.staticfile.org/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="https://cdn.staticfile.org/hexo-theme-next/8.17.1/third-party/math/mathjax.min.js"></script><script class="next-config" data-name="twikoo" type="application/json">{"enable":true,"visitor":false,"envId":"https://www.aliang.link/twikoo","jsUrl":"https://cdn.staticfile.org/twikoo/1.6.16/twikoo.all.min.js","el":"#twikoo-comments"}</script><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.twikoo.el).then(()=>NexT.utils.getScript(CONFIG.twikoo.jsUrl||"https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js",{condition:window.twikoo})).then(()=>{twikoo.init(CONFIG.twikoo)})})</script><style>.comments,.post-block{overflow:visible}.tk-owo-emotion{display:inline-block}</style><script data-pjax type="text/javascript">var $linkList=$(".link-list");if(0!=$linkList.length)for(var j=-1,i=0;i<$linkList.length;i++){const n=$linkList[i].getAttribute("json-src"),t=$linkList[i].getAttribute("icon-src");$.getJSON(n,(function(i){j++;var n="";$linkList.eq(j).empty(),$.each(i,(function(i,l){var a="",s="";l.warn&&(a='<span class="label warn">'+l.warn+"</span>"),l.info&&(s='<span class="label info">'+l.info+"</span>"),n+='<div class="link-list-container">',n+='<img class="link-list-image" src="'+t+l.logo+'">',n+="<p>"+l.title+s+a+"</p>",n+="<p>"+l.intro+"</p>",n+='<a href="'+l.url+'" rel="noopener" target="_blank" data-pjax-state=""></a>',n+="</div>"})),$linkList.eq(j).html(n)}))}</script><script data-pjax type="text/javascript">var $imgCardList=$(".img-card-list");if(0!=$imgCardList.length)for(var j3=-1,i=0;i<$imgCardList.length;i++){const t=$imgCardList[i].getAttribute("json-src");$imgCardList[i].getAttribute("icon-src");$.getJSON(t,(function(i){j3++;var t="";$imgCardList.eq(j3).empty(),$.each(i,(function(i,s){t+='<div class="card-item">',t+='<a href="'+s.link+'" target="_blank">',t+='<div class="box-img">',t+='<img src="'+s.img+'" class="no-zoom" style="object-fit: cover;">',t+="</div>",t+='<div class="box-info">',t+='<p class="name" style="-webkit-line-clamp: 1;">'+s.title+"</p>",t+='<p class="desc" style="-webkit-line-clamp: 1;">'+s.desc+"</p>",t+="</div>",t+='<div class="box-footer">',t+='<img src="'+s.head+'" class="no-zoom">',t+="<span>"+s.author+"</span>",t+="</div>",t+="</a>",t+="</div>"})),$imgCardList.eq(j3).html(t)}))}</script><script data-pjax type="text/javascript">var $cultureList=$(".culture-list");if(0!=$cultureList.length)for(var j=-1,i=0;i<$cultureList.length;i++){const e=$cultureList[i].getAttribute("json-src"),t=$cultureList[i].getAttribute("cover-src");$.getJSON(e,(function(e){j++;var s="";$cultureList.eq(j).empty(),$.each(e,(function(e,i){var r=i.title;if(i.id&&(r='<a href="/blog/'+i.id+'/" >'+i.title+"</a>"),i.author)var a='<span class="author">'+i.author+"</span>";else a="";if(i.intro)var c=i.intro;else c="";if(null==i.score)var l="";else{var o="",v="",u=i.score-i.score%1,d=0;i.score%1!=0&&(d=1);for(var n=0;n<u;n++)o+="★";0!=d&&(o+="☆");for(n=0;n<5-d-u;n++)v+="☆";l=5!=i.score?'<span class="star-score">'+o+'<span class="grey-star">'+v+"</span></span>":'<span class="star-score">'+o+"</span>"}var m="";m=-1===i.cover.indexOf("http")?t+i.cover:i.cover,s+='<div class="media">',s+='<div class="media-cover" style="background-image:url('+m+')"></div>',s+='<div class="media-meta">',s+='<div class="media-meta-item title">'+r+"</div>",s+='<div class="media-meta-item">'+a+l+"</div>",s+='<div class="media-meta-item intro">'+c+"</div>",s+="</div></div>"})),$cultureList.eq(j).html(s)}))}</script><script src="/assets/minigrid.min.js"></script><script data-pjax type="text/javascript">var $album=$(".album")[0];if($album){var imgDataPath=$album.getAttribute("json-src"),imgPath=$album.getAttribute("photo-src"),imgMaxNum=50,windowWidth=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth;if(windowWidth<768)var imageWidth=145;else imageWidth=235;var LinkDataPath=imgDataPath;photo={page:1,offset:imgMaxNum,init:function(){var t=this;$.getJSON(LinkDataPath,(function(i){t.render(t.page,i)}))},render:function(t,i){var a=(t-1)*this.offset,e=t*this.offset;if(!(a>=i.length)){for(var n,o,m,d,r,h="",g=a;g<e&&g<i.length;g++)o=(n=i[g].split(" ")[1]).split(".")[0],d=(m=i[g].split(" ")[0]).split(".")[0],r=m.split(".")[1],h+='<div class="card" style="width:'+imageWidth+'px" >',h+='<div class="album-photo" style="height:'+imageWidth*r/d+'px">',h+='<a class="fancybox fancybox.image" href="'+imgPath+n+'" itemscope="" itemtype="http://schema.org/ImageObject" itemprop="url" data-fancybox="group" rel="group" data-caption="'+o+'" title="'+o+'">',h+='<img data-src="'+imgPath+n+'" src="'+imgPath+n+'" alt="'+o+'" data-loaded="true">',h+="</a>",h+="</div>",h+="</div>";$(".album").append(h),this.minigrid()}},minigrid:function(){var t=new Minigrid({container:".album",item:".card",gutter:12});t.mount(),$(window).resize((function(){t.mount()}))}},photo.init()}</script></body></html>